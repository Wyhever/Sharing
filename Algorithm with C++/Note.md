# Graphical Algorithm using C++
使用C++圖說演算法

## Chapter 1 運算思維與程式設計
1. 演算法條件: 輸入、輸出、有限、有效、明確
2. 時間複雜度: O(f(n))
    1. O(1): 常數時間，演算法的執行時間是一個常數倍
    2. O(n): 線性時間，執行時間會隨資料集合的大小而線性成長
    3. O(log2n): 次線性時間，成長速度必線性時間慢，但比常數時間還快
    4. O(n^2): 平方時間，演算法執行時間會成二次方成長
    5. O(n^3): 立方時間，演算法執行時間會成三次方成長
    6. 2^n: 指數時間，演算法執行時間會成2^n次方成長
    7. O(nlog2n): 線性乘對數時間，介於線性與二次方成長的中間行為模式
3. 結構化程式設計
4. 物件導向程式設計
    1. 封裝性: 利用類別 (class) 來實作抽象化資料型態
    2. 繼承性: 允許程式碼的重複使用，並表達樹狀結構中父代與子代的遺傳現象
        1. private: 私有成員，最高保護層級，類別中預設存取型態為私有成員
        2. protected: 保護成員，只被繼承的類別所使用
        3. public: 公用成員，可被其他物件或外部程式呼叫與存取
    4. 多形性: 讓軟體在發展與維護時具有延展性
        1. 繼承類別新增成員函數
        2. 繼承時重新定義成員函數內容
        3. 基礎類別定義為虛擬函數，於類別被繼承時重新實作該函數內容

## Chapter 2 經典演算法
1. 分治演算法
2. 遞迴演算法: 一個函數或副程式，是由自身所定義或呼叫
    1. 階層函數演算法
    2. 費氏數列演算法
3. 動態規劃演算法: 與分治法不同的地方，將每個子問題的答案儲存下來，以供下次求解時取用，避免重複計算
4. 疊代演算法: 變數初始值、迴圈條件式、調整變數增減值
    1. 巴斯卡三角形演算法
5. 枚舉演算法
    1. 質數求解演算法
6. 回溯法
    1. 迷宮路線搜索: 利用串列堆疊紀錄路線
7. 貪心法

## Chapter 3 資料結構
1. 陣列 (Array): 靜態資料結構，將有序串列的資料結構使用連續記憶空間來儲存
    1. 缺點: 刪除或加入資料時，需要移動大量資料
2. 鏈結串列 (Linked list): 動態配置記憶體空間
    1. 資料欄位
    2. 指標欄位: 指向下一個元素的記憶體所在位置
3. 堆疊 (Stack): 所有操作皆在頂端執行，具"後進先出"的特性
    1. create: 建立一個空堆疊
    2. push: 存放頂端資料，並傳回新堆疊
    3. pop: 刪除頂端資料，並傳回新堆疊
    4. isEmpty: 判斷堆疊是否為空堆疊
    5. full: 判斷堆疊是否已滿
4. 佇列 (Queue): 加入與刪除的動作都發生在不同的兩端，具"先進先出"的特性
    1. create: 建立一個空佇列
    2. add: 將新資料加入佇列尾端，傳回新佇列
    3. delete: 刪除佇列前端資料，傳回新佇列
    4. front: 傳回佇列前端資料
    5. empty: 判斷佇列是否為空
5. 二元樹 (Binary tree): 有限節點所組成的集合，此集合可以為空集合
    1. 二元樹可為空集合
    2. 節點分支度: 0 <= d <= 2
    3. 子樹間有次序關係
6. 圖形: 由"頂點"與"邊"組成的集合
    1. 無向圖形 (Graph)
    2. 有像圖形 (Digraph)
7. 雜湊表 (Hashing)
    1. bucket: 儲存資料的位置
    2. slot: 儲存資料的欄位
    3. collision: 若兩筆資料，經過雜湊函數運算後，對應到相同的位置時，稱為碰撞
    4. 溢位: 若資料經過雜湊函數運算後，所對應的bucket已滿，則會使bucket溢位
 
## Chapter 4 排序演算法
1. 時間複雜度 (Time complexity)
2. 空間複雜度 (Space complexity): 資料對調需要暫時使用到一個額外空間
3. 演算法:
    1. 氣泡排序法:
        1. 最壞及平均時間複雜度: O(n^2)，最好時間複雜度: O(n)
        2. 不會改變原本排列順序，穩定排序法
        3. 只需要一個額外空間，空間複雜度最佳
        4. 適用小資料量或部分資料已經過排序
    2. 選擇排序法:
        1. 無論任何情況，皆須找到數列極值，時間複雜度: O(n^2)
        2. 資料排列順序可能被改變，不是穩定排序法
        3. 只需要一個額外空間，空間複雜度最佳
        4. 適用小資料量或部分資料已經過排序
    3. 插入排序法:
        1. 最壞及平均時間複雜度: O(n^2)，最好時間複雜度: O(n)
        2. 穩定排序法
        3. 只需要一個額外空間，空間複雜度最佳
        4. 適用大部分資料已經過排序，或新增資料進入已排序資料中
        5. 會造成大量資料搬移，建議在鏈結串列上使用
    4. 謝耳排序法
        1. 無論任何情況，皆須找到數列極值，時間複雜度: O(n^3/2)
        2. 使用插入排序法，為穩定排序法
        3. 只需要一個額外空間，空間複雜度最佳
        4. 適用大部分資料已經過排序
    5. 快速排序法 (分割交換排序法)
        1. 最壞及平均時間複雜度: O(n^2)，最好時間與平均複雜度: O(nlogn)
        2. 非穩定排序法
        3. 最差空間複雜度: O(n)，最佳空間複雜度: O(logn)
        4. 目前公認最佳排序法，平均執行時間最快
    6. 合併排序法: 針對以排序好的多個數列經由合併，組成一個大的且以排序好的數列
        1. 最壞、平均與最好時間與平均複雜度: O(nlogn)
        2. 穩定排序法
        3. 空間複雜度: O(n)
    7. 基數排序法
        1. 時間複雜度: O(nlog p k)，k代表資料的最大值
        2. 穩定排序法
        3. 空間複雜度 O(n*p)，n 代表資料個數, p代表位元數
        4. 若n很大，p很小或固定，基數排序法將很有效率
    8. 堆積樹排序法
        1. 時間複雜度O(nlogn)
        2. 非穩定排序法
        3. 空間複雜度O(1)

## Chapter 5 搜尋演算法
1. 內部搜尋法: 資料量較小，可以一次將全部資料載入記憶體進行搜尋
2. 外部搜尋法: 資料量龐大，先將資料組織化存入磁碟中，搜尋時根據組織性來達成
3. 演算法:
    1. 循序搜尋法: 將資料一筆一筆的循序逐次搜尋
        1. 最差時間複雜度O(n)
        2. 平均狀況下，假設資料出線機率相等，則需進行(n+1)/2次比較
        3. 循序搜尋法不適合資料量很大的情況
    2. 二分搜尋法
        1. 時間複雜度O(logn)
        2. 資料須事先排序，並且能在記憶體中執行
        3. 適合不須增刪的靜態資料
    3. 內插搜尋法: 二分搜尋法的改版，根據資料位置的分布，利用公式預測資料的所在位置，再以二分法逼近
        1. 內插搜尋法一般優於循序法，資料分布越平均，搜尋速度越快，時間複雜度優於O(logn)
        2. 資料須事先排序
    4. 費氏搜尋法: 與二分法一樣都是切割範圍進行搜尋，不同的是費氏搜尋法不以對半分割，而是以費氏級數進行分割
        1. 優點指使用加減運算，以電腦運算過程來看，效率會高於二分搜尋法
        2. 平均而言，費氏搜尋法比較次數會少於二次搜尋法，但最壞情況下，二元搜尋法較快；平均時間複雜度O(log2 N)
        3. 費氏搜尋法較複雜，需額外產生費氏樹

## Chapter 6 陣列與串列演算法
1. 資料結構
    1. 靜態資料結構: 陣列型態將有序串列的資料使用連續記憶體空間儲存，設計相對簡單，讀取修改任一元素的時間都固定，缺點是當刪除或加入資料時需要移動大量資料。
    2. 動態資料結構: 鏈結串列使用不連續記憶空間來儲存 ，資料插入予刪除相當方便且節省記憶體，缺點是設計資料結構較為複雜，搜索資料時必須透過循序方法找到對應資料。
2. 矩陣演算法
    1. 矩陣相加
    2. 矩陣相乘
    3. 轉置矩陣
    4. 稀疏矩陣: 使用三項式紀錄矩陣內容，減少記憶體浪費
3. 陣列與多項式
    1. 方法1: 使用一個n+2長度的一維陣列存放多項式的係數，陣列第一個位置儲存最大指數n，其他依序遞減儲存對應係數 
    2. 方法2: 只儲存多項式非零項目，如果有m項非零項目則使用m+1長度的陣列儲存陣列的非零項指數與係數，但第一個元素記錄此多項式的非零個數
4. 串列演算法
    1. 建立鏈結串列(linked listed)
        1. 配置動態配置記憶體給新節點使用
        2. 將串列尾端指標 (next) 指向新元素所在記憶體位置
        3. 將ptr指標指向新節點的記憶體位置，表示這是新的串列尾端
        4. 將新節點的指標 (next) 指向NULL，表示為最後一個元素
    2. 插入節點演算法
        1. 新節點插入第一節點之前，成為串列的首節點 
        2. 新節點插入最後一節點之後
        3. 新節點插入串列中間
    3. 刪除節點演算法
        1. 刪除第一個節點
        2. 刪除最後一個節點
        3. 刪除中間節點
    4. 反轉串列演算法
    5. 串列連結演算法
    6. 串列與多項式

## Chapter 7 安全性演算法
1. 資料加密
    1. 對稱鍵值加密系統: 使用秘密金鑰進行加密與解密
        1. DES (Data encryption standard, 資料加密標準)  
        2. Triple DES
        3. IDEA (International data encryption algorithm, 國際資料加密演算法)
    2. 非對稱鍵值加密系統: 使用公開金鑰進行加密，使用私密金鑰進行解密
        1. RSA: 採用隨機選出的超大質數p,q，利用兩個質數作為加密與解密的兩個鑰匙
    3. 認證
    4. 數位簽證
2. 雜湊演算法
    1. 除法: 選擇一質數k，將資料除以k後，取其餘數作為索引
    2. 中間平方法: 將資料乘以自己後，再取中間的某段數字作為索引
    3. 摺疊法: 將資料轉換成一串數字後，先將該串數字拆成數個部分，最後再將它們加起來，就可以計算出該鍵值的bucket address
        1. 邊界摺疊法: 將拆成數個部份的數字，選擇奇數段或偶數段的數字反轉後再相加，降低索引碰撞機會
    4. 數位分析法
3. 碰撞與溢位處理
    1. 定義 
        1. 碰撞: 關鍵鍵值不同，經過雜湊後得到相同的位址
        2. 溢位: 當識別字要放入某個bucket時，但該bucket卻已經滿了 
    2. 線性探測法: 當發生碰撞時，則以線性的方式往後尋找空的儲存位置
    3. 平方探測法
    4. 再雜湊法: 設置一系列的雜湊函數，若第一種雜湊法發生溢位，則使用第二種，直到沒有發生溢位
    5. 鏈結串列: 將雜湊表的所有空間建立n個串列，最初只有n個串列首，如果發生溢位，就將相同位址的鍵值鏈結在串列首後，直到所有可用空間用盡

## Chapter 8 堆疊與佇列
1. 陣列實作堆疊
2. 串列實作堆疊
3. 河內塔演算法
4. 八皇后演算法
5. 陣列實作佇列
6. 串列實作佇列
7. 雙向佇列

## Chapter 9 樹狀演算法
1. 樹狀結構
    1. 完滿二元樹
    2. 完整二元樹
    3. 歪斜樹
    4. 嚴格二元樹
2. 陣列實作二元樹
    1. 預設為完滿二元樹，第k個階度具有k-1個節點
    2. 左子樹索引值是父節點索引值*2
    3. 右子樹索引值是父節點索引值*2+1
    4. 二元搜索樹
        1. 可以是空集合，但若不是空集合則節點上一定要有一個鍵值
        2. 每個樹根的值須大於左子樹的值
        3. 每個樹根的值須小於右子樹的值 
        4. 左右子樹也是二元搜索樹
        5. 樹的每個節點值都不相同
3. 串列實作二元樹
4. 二元樹走訪
    1. 中序走訪: 左子樹->樹根->右子樹
    2. 前序走訪: 樹根->左子樹->右子樹
    3. 後序走訪: 左子樹->右子樹->樹根
5. 二元搜索樹: 左子樹<樹根<右子樹
6. 二元樹節點插入
    1. 搜尋二元樹，如果二元樹已有此節點，則沒有插入必要，反之再將此節點加入二元樹中
7. 二元樹節點刪除
    1. 刪除節點為樹葉
    2. 刪除節點只有一顆子樹
    3. 刪除節點有兩棵子樹
        1. 方法一: 將欲刪除的節點的左子樹最大者向上提
        2. 方法一: 將欲刪除的節點的右子樹最小者向上提
8. 二元運算樹
9. 二元排序樹
10. 引線二元樹: 將空的鏈結加以利用，再指到樹的其他節點，這些鏈結就稱為"引線"
    1. 將二元樹以中序走訪方式依序排出，將所有空鏈結改成引線
    2. 若引線鏈結指向該節點的左鏈結，則將該引線指到中序走訪順序下的前一個節點
    3. 若引線鏈結指向該節點的右鏈結，則將該引線指到中序走訪順序下的後一個節點
    4. 指向一個空節點，將此節點的右鏈結指向自己，空節點的左子樹是此引線二元樹
11. 延伸二元樹
    1. 任何一個二元樹，若有n個節點，則有n-1個非空鏈結與n+1個空鏈結
    2. 在每一個空鏈結加上一個特定節點，則稱為外節點，其餘節點稱為內節點，且定義此種樹圍"延伸二元樹"
    3. 外徑長 = 所有外節點到樹根距離的總和
    4. 內徑長 = 所有內節點到樹根距離的總和
12. 霍夫曼樹: 根據資料出現的頻率來建構二元樹，用於進行資料壓縮的演算法
13. 平衡樹:
    1. 二元搜尋樹的缺點是無法保持在最佳狀態，當加入的部分資料已排序的情況下，即可能產生歪斜樹，導致搜尋效率降低
    2. T是一個非空的二元樹，Tl與Tr分別是T的左右子樹，若符合以下條件，則稱T為高度平衡樹
        1. Tl與Tr也是高度平衡樹
        2. |hl-hr|<=1，hl與hr分別為Tl與Tr的高度，所有內部節點的左右子樹高度必定小於等於1
14. 決策樹

## Chapter 10 圖形演算法
1. 資料表示法
    1. 相鄰矩陣法
        1. 無向圖形，相鄰圖形一定是對稱的，且對角線一定為0；有向圖形則非
        2. 無向圖形中，任一節點i的分支度即為該i列所有元素和
        3. 有像圖形中，任一節點 (i,j) 的出分支度即為該i列所有元素和，出分支度即為該j行所有元素和
        4. 用相鄰矩陣法表示圖形需要n^2空間，無向圖形由於對稱特性，只需儲存上半三角形的資料，因此僅需n(n-1)/2的空間
        5. 計算所有頂點的分支度，其時間複雜度為O(n^2)
    2. 相鄰串列法
        1. n個頂點形成n個串列首，每個串列中的節點表示他們與首節點有邊相連
        2. 無向圖形中，因為對稱的特性，若有n個節點，m個邊，則形成n個串列首，2m個節點
        3. 有向圖形中，則形成n個串列首，m個節點
        4. 計算所有頂點的分支度，其時間複雜度為O(n+m)
    3. 相鄰複合串列法
        1. 應用於無向圖形，相鄰多元串列的節點存放邊線的資料
        2. M: 紀錄該邊是否被找過的一位元欄位
        3. V1與V2: 紀錄邊的起點與終點
        4. Link1: 尚有其他頂點與V1相連的情況下，此欄位會指向下一個與V1相連的邊節點，反之則為NULL
        5. Link2: 尚有其他頂點與V2相連的情況下，此欄位會指向下一個與V2相連的邊節點，反之則為NULL
    4. 索引表格法
        1. 用一維陣列依序儲存與各頂點相鄰的所有頂點，並建立索引表格，來記錄個頂點與此一維陣列中第一個與該頂點相鄰的位置
2. 圖形走訪
    1. 先深後廣走訪法: 
        1.  從圖形中某一個頂點開始走訪，被走訪過的頂點就加上已走訪的記號，接著走訪此頂點所有相鄰且未被走訪過的頂點中的其中一點，再以該點為新的起點繼續先深後廣的的搜尋
        2.  使用堆疊與遞迴技巧
    2. 先廣後深走訪法: 
        1.  從圖形中某一個頂點開始走訪，被走訪過的頂點就加上已走訪的記號，接著走訪此頂點所有相鄰且未被走訪過的頂點中的其中一點，再以該點為新的起點繼續先廣後深的的搜尋
        2.  使用佇列與遞迴技巧
3.  擴張樹
    1. 以最少的邊來連結圖形中所有的頂點，且不造成循環的樹狀構造 
    2. 最小花費擴張樹: 假設在樹的邊加上一個權重值，此種圖形就成為"加權圖形"；若這個權重值代表兩個頂點間的距離或成本，此類圖形就稱為網路
        1. Prim 演算法: 對一個加權圖形 G=(V,E)，設V={1,2,...n}，假設U={1}，U及V是兩個頂點的集合，從U-V的差集所產生的集合中找出一個頂點x，該頂點x能與U集合中的某一個頂點形成最小成本的邊，且不會造成迴圈。然後將此頂點加入U集合中，反覆重複同樣的步驟，直到U集合等於V集合
        2. Kruskal演算法: 將各邊線一權值大小排列，接著從權值最低的邊線開始架構最小成本擴張樹，若加入的邊線會造成迴圈則捨棄不用，直到加入了n-1個邊為止
4. 圖形最短路徑法
    1. Dijkstra演算法: 1個頂點到多個頂點；廣度優先的搜索演算法
        1. 假設S = {Vi|Vi in V}，Vi在已發現的最短路徑，其中Vi in S是起點
        2. 假設w not in S，定義Dist(w)是從V0到w的最短路徑，這條路徑除了w以外皆屬於S
    2. A*演算法 
        1. Dijkstra演算法的改良版
        2. 預先設定一個"推測權重"
        3. 推測權重就是根據事先知道的資訊來給定一個預估值
    3. Floyd演算法
        1. 可計算出圖形中任意兩點甚至所有頂點間最短的距離
        2. 利用更新每次經過不同中繼點計算出最短路徑矩陣
      
