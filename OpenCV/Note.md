# OpenCV 影像處理 
使用Python
## 01 OpenCV 入門
1. 基本操作
    1. 讀取影像: cv2.imread(filename)
    2. 顯示影像: cv2.imshow(winname, mat)
    3. 儲存影像: cv2.imwrite(filename, img)
    
## 02 影像處理基礎
1. 影像的基本表示法
    1. 二值影像
    2. 灰階影像
        1. 數值區間[0, 255], 0代表純黑色, 255代表純白色
2. 像素處理
    1. 彩色影像
        1. RGB模式的彩色影像在讀取時，會按照方向一次讀取該RGB的B 通道,G 通道和R 通道的像素點
3. 使用numpy.array存取像素
    1. item()高效率取得影像的像素點
    2. itemset()用來修改像素質
4. 有興趣區域(ROI)
5. 通道操作
    1. 通道拆分
    2. 通道合併
6. 影像屬性
    1. shape: 傳回行數、列數、通道數的陣列
    2. size: 傳回影像的像素數目
    3. type: 傳回影像的資料類型
## 03 影像運算
1. 影像加法運算
    1. cv2.add()
2. 影像加權和
    1. cv2.addWeighted()
3. 逐位元邏輯運算
    1. 逐位元與
    2. 逐位元或
    3. 逐位元互斥
    4. 逐位元反轉
4. 遮罩
    1. 當使用遮罩參數時，操作只會在遮罩值不為0的像素點執行，並將其他像素點設為0
5. 影像與數值計算
6. 位元平面分解
    1. 8位元灰階圖可以組成8個二進位值影像，即可將原圖分解為8個位元平面
    2. 對不同位元平面可使用逐位元互斥達成影像加密與解密的功能    
    3. 對第0位元平面嵌入影像資訊，由於對載體影像不明顯，可以達成數字浮水印的目的
## 04 色彩空間類型轉換
1. 色彩空間基礎
    1. GRAY色彩空間(灰階影像)
    2. XYZ色彩空間
        1. 一種更便於計算的色彩空間
    3. YCrCb色彩空間
        1. 人眼視覺系統(HVS)對顏色的敏感度要低於對亮度的敏感度
        2. Y代表亮度，Cr代表紅色分量資訊，Cb代表藍色分量資訊
    4. HSV色彩空間
        1. 一種針對視覺感知的色彩模型
        2. 色調(Hue),飽和度(Saturation),亮度(Value)
    5. HLS色彩空間
        1. 色調(Hue),光亮度/明度(Lightness),飽和度(Saturation)
    6. Lab色彩空間
        1. 均勻色彩空間模型，是一種針對視覺感知的色彩模型
        2. L表示像素亮度[0,100],從純黑到純白
        3. a表示從紅色到綠色的範圍[-127,127]
        4. b表示從黃色到藍色的範圍[-127,127]
    7. Luv色彩空間
        1. 均勻色彩空間模型，適用於顯示器顯示和根據加色原理進行組合的場合
        2. 比較強調紅色的表示，對紅色的變化比較敏感，但對藍色的變化不太敏感
    8. Bayer色彩空間
        1. 廣泛應用於CCD和CMOS相機中
        2. 輸出的RGB影像像素值，是根據目前點的1個、2個或4個鄰域像素點的相同顏色像素值所獲得
2. 類型轉換函數
    1. 函數: cv2.cvtColor()
3. alpha通道
    1. 在RGB色彩空間三個通道的基礎上，可以再加上一個A通道，表示透明度
## 05 幾何轉換 
1. 縮放
    1. 函數: cv2.resize() 
2. 翻轉
    1. 函數: cv2.flip()  
2. 仿射
    1. 透過一系列的幾何轉換來實現平移、旋轉等操作。該轉換能保持影像的平直性與平行性。
    2. 函數: cv2.warpAffine()   
    3. 平移
        1. 透過自訂轉換矩陣M平移影像
    4. 旋轉
        1. 函數: cv2.getRotationMatrix2D()   
    5. 更複雜的仿射轉換
        1. 產生轉換矩陣函數: cv2.getAffineTransfoem()
        2. 利用輸入與輸出影像的3個點座標產生轉換矩陣，再利用轉換矩陣進行轉換
3. 透視
    1. 仿射轉換可將矩形對映為任意平行四邊形；透視轉換可將矩形對映為任意四邊形
    2. 函數: cv2.warpPerspective()   
    3. 產生轉換矩陣函數: cv2.getPerspectiveTransfoem()
    4. 利用輸入與輸出影像的4個點座標產生轉換矩陣，再利用轉換矩陣進行轉換
4. 重對映
    1. 將一幅影像內的像素點放置到另一幅影像內的指定位置 
    2. 函數: cv2.remap()   
    3. 影像旋轉
    4. 繞x軸翻轉
    5. 繞y軸翻轉
    6. 繞x, y軸翻轉
    7. x, y軸互換
    8. 影像縮放
## 06 設定值處理
1. threshold函數
    1. 函數: cv2.threshold()
    2. 二值化設定值處理
    3. 反二值化設定值處理
    4. 截斷設定值化處理
    5. 超設定值零處理
    6. 低設定值零處理
2. 自我設定值處理
    1. 透過計算每個像素點周圍鄰近區域的加權平均值獲得設定值，並使用該設定值對目前像素點進行處理
    2. 函數:cv2.adaptiveThreshold()
3. Otsu處理[demo]
    1. 根據目前影像列出最佳的類別間分割設定值
    2. 函數:cv2.THRESH_OTSU
## 07 影像平滑處理
1. 均值濾波
    1. 用目前項速點周圍N*N個像素值的均值來代替目前像素值
    2. 函數: cv2.blur()
2. 方框濾波
    1. 可以自由選擇是否對均值濾波的結果進行歸一化
    2. 函數: cv2.boxFilter()
3. 高斯濾波
    1. 會將中心點的加權值加強，遠離中心點的加權值減小，在此基礎上計算鄰域內各像素值不同加權的和
    2. 函數: cv2.GaussianBlur()
4. 中值濾波
    1. 用鄰域內所有像素值的中間值來代替目前像速點的像素值
    2. 函數: cv2.medianBlur()
5. 雙邊濾波
    1. 綜合考量空間資訊和色彩資訊，在濾波過程中能夠有效保護影像內的邊緣資訊
    2. 函數: cv2.bilateralFilter()
6. 2D旋積
    1. 使用特定(自訂)的旋積核進行旋積操作
    2. 函數: cv2.filter2D()
## 08 形態學操作
1. 腐蝕
    1. 將影像的邊界點消除，使影像沿著邊界向內收縮，也可將小於指定結構元素的部分消除
    2. 函數: cv2.erode()
2. 膨脹
    1. 對影像的邊界進行擴張
    2. 函數: cv2.dilate()
3. 開運算
    1. 先將影像腐蝕，再對腐蝕的影像進行膨脹；用於去噪、計數
    2. 語法: cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
4. 閉運算
    1. 先將影像膨脹，再對膨脹的影像進行腐蝕；用於閉合前景物體內部的小孔，或進行不同前景影像的連接
    2. 語法: cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)
5. 形態學梯度運算[demo]
    1. 將影像的膨脹後的影像減去影像的腐蝕影像；可以取得影像的邊緣
    2. 語法: cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)
6. 禮帽運算[demo]
    1. 將原始影像減去其開運算處理後的影像；可以取得影像的雜訊資訊，或獲得比原始影像的邊緣更亮的邊緣資訊
    2. 語法: cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)
7. 黑帽運算[demo]
    1. 將閉運算處理後的影像減去原始影像；可以取得影像內部的小孔，或獲得比原始影像的邊緣更暗的邊緣資訊
    2. 語法: cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)
8. 核函數(kernel)
    1. 傳回一個用於形態學處理所使用的結構函數
    2. 語法: cv2.getStructuringElement(shape, ksize[,anchor])
## 09 影像梯度   
影像梯度計算的是影像變化的速度，或者說是影像的邊緣資訊
1. Sobel[demo]
    1. 利用局部差分尋找邊緣，計算所得的是一個梯度的近似值
    2. 語法: cv2.Sobel()
2. Scharr[demo]
    1. Sobel運算元的改進
    2. 語法: cv2.Scharr()
3. Laplacian運算元及函數使用[demo]
    1. 二階導數運算元 ，具有旋轉不變性，可以滿足不同方向的影像邊緣銳化(邊緣檢測)
    2. 2. 語法: cv2.Laplician()
4. 運算元歸納
    1. 一階近似導數
        1. Sobel = |左-右|/|下-上|
        2. Scharr = |左-右|/|下-上|
    2. 二階近似導數
        1. Laplacian = |左-右|+|左-右|+|下-上|+|下-上|
## 10 Canny 邊緣檢測
一種使用多級邊緣檢測的演算法
1. Canny邊緣檢測[demo]
    1. 去躁
        1. 高斯濾波去除影像雜訊
    2. 計算梯度的幅度與方向
        1. 梯度方向與邊緣方向垂直
    3. 非極大值抑制，適當地讓邊緣變瘦
        1. 檢查影像中的向速點，去除所有非邊緣的點
    4. 確定邊緣
        1. 若邊緣像素的梯度值大於等於高設定值，則標記為強邊緣
        2. 若邊緣像素的梯度值介於高設定值與低設定值，則標記為虛邊緣；若虛邊緣與強邊緣相連則保留，否則剔除
        3. 若邊緣像素的梯度值小於等於低設定值，則剔除
2. Canny函數
    1. 語法: cv2.canny()
## 11 影像金字塔
影像金字塔是由一幅影像的多個不同解析度的子圖所組成的影像集合
1. 理論基礎
    1. 透過對原影像不斷地向下取樣而產生，即由高解析度的影像產生低解析度的近似影像
2. pyrDown函數及使用
    1. 用於實現影像高斯金字塔操作中的向下取樣
    2. 語法: cv2.pyrDown() 
3. pyrUp函數及使用
    1. 用於實現影像高斯金字塔操作中的向上取樣
    2. 語法: cv2.pyrUp() 
4. 拉普拉斯金字塔[demo]
    1. 向上取樣並不是向下取樣的逆運算；為了在向上取樣時能夠恢復具有較高解析度的原始影像，就要取得在取樣過程中所遺失的資訊，這些遺失資訊就組成了拉普拉斯金字塔
    2. 拉普拉斯金字塔中的第i層，等於"高斯金字塔中的第i層"與"高斯金字塔中的第i+1層的向上取樣結果"之差
    3. 拉普拉斯進字塔的作用在於，能夠恢復高解析度的影像
## 12 影像輪廓
1. 尋找並繪製輪廓
    1. 尋找影像輪廓
        1. 語法: cv2.findContours()
    2. 繪製影像輪廓
        1. 語法: cv2.drawContour()
2. 矩特徵
    1. 矩的計算
        1. 輪廓矩描述了一個輪廓的重要特徵，使用輪廓矩可以方便地比較兩個輪廓
        2. 語法: cv2.moments()
    2. 計算輪廓面積
        1. 語法: cv2.contourArea()
    3. 計算輪廓長度
        1. 語法: cv2.arcLength()
3. Hu矩
    1. 取得Hu矩
        1. 歸一化中心矩的線性組成；Hu矩在影像旋轉、縮放、平移等操作後，仍能保持矩的不變性
        2. 語法: cv2.HuMoments()
    2. 形狀比對
       1. 對兩個物件的Hu矩進行比較，越相近差值越接近0
       2. 語法: cv2.matchShapes() 
4. 輪廓擬合
    1. 矩形包圍框
        1. 語法: cv2.boundingRect()
    2. 最小包圍矩形框
        1. 語法: cv2.minAreaRect()
    3. 最小包圍圓形
        1. 語法: cv2.minEnclosingCircle()
    4. 最佳擬合橢圓
        1. 語法: cv2.fitEllipse() 
    5. 最佳擬合直線
        1. 語法: cv2.fitLine()  
    6. 最小外包三角形
        1. 語法: cv2.minEnclosingTriangle()  
    7. 逼近多邊形
        1. 語法: cv2.approxPolyDP()
5. Convex|Hull
    1. 取得Convex|Hull
        1. 指得是完全包含原有輪廓，並且僅由輪廓上的點所組成的多邊形
        2. 語法: cv2.convexHull()
    2. 凸缺陷
        1. Convex|Hull與輪廓之間的部分，稱為凸缺陷
        2. 語法: cv2.convexityDefects()
    3. 幾何測試
        1. 測試輪廓是否是凸形: cv2.isContourConvex()
        2. 點到輪廓的距離: cv2.pointPolygonTest() 
6. 利用形狀場景演算法比較輪廓
    1. 計算形狀場景距離[demo]
        1. 形狀上下文演算法在計算距離十，在每個點上附加一個"形狀上下文"描述符號，讓每個點都能夠捕捉剩餘點相對於它的分布特徵，進一步提供全域鑑別特徵
        2. 語法: cv2.createShapeContexDistanceExtractor()
    2. 計算Hausdorff距離[demo]
        1. Hausdorff距離是根據物件A與物件B之間的Hausdorff直接距離來定義
        2. 語法: cv2.createHausdorffDistanceExtractor()
7. 輪廓的特徵值
    1. 長寬比
    2. Extent
        1. 輪廓面積(物件面積)與矩形邊界面積的比值
    3. Solidity
        1. 輪廓面積(物件面積)與Convex|Hull面積的比值
    4. 相等直徑
        1. 與輪廓面積相等的圓形直徑
    5. 方向
        1. 最佳擬合橢圓
    6. 掩模與像素點
        1. numpy.nonzero()找出陣列內非零元素的位置
        2. cv2.findNonZero()用於尋找非零元素的索引
    7. 最大值最小值和它們的位置
        1. 語法:cv2.minMaxLoc()
    8. 平均顏色與平均灰階
        1. cv2.mean()
    9. 極點
        1. leftmost = tuple(cnt[cnt[:,:,0].argmin()][0])
        2. rightmost = tuple(cnt[cnt[:,:,0].argmax()][0]) 
        3. topmost = tuple(cnt[cnt[:,:,1].argmin()][0])
        4. bottommost = tuple(cnt[cnt[:,:,1].argmax()][0])
## 13 長條圖型處理
1. 長條圖的含意
    1. 長條圖統計圖像內各個灰階值出現的次數
2. 繪製長條圖
    1. 使用numpy繪製長條圖
        1. 語法: matplotlib.pyplot.hist() 
    2. 使用OpenCV繪製長條圖
        1. 語法: cv2.calcHist()
3. 長條圖均衡化[demo]
    1. 若一幅影像能擁有全部可能的灰階，並且像素值的灰階均勻分布，那這幅影像就具有高比較和多變的灰階色調；在外觀上，影像也不會過亮或過暗
    2. 原理
        1. 計算累計長條圖
        2. 對累計長條圖進行區間轉換
    3. 語法: cv2.equalizeHist() 
## 14 傅立葉轉換
1. 理論基礎
    1. 傅立葉轉換能將影像從空間域轉換到頻率域，然後在頻率域對影像進行處理，最後再透過反轉換將影像從頻率域轉換為空間域 
    2. 任何週期函數都可以表示為不同頻率的正弦函數和
    3. 低頻資訊對應影像內變化緩慢的灰階分量
    4. 高頻資訊對應影像內變化越來越快的灰階分量，是由灰階的尖銳過度造成
2. Numpy實現傅立葉轉換[demo]
    1. 高通濾波: 過濾低頻資訊保留高頻資訊
    2. 實現傅立葉轉換
        1. 語法: numpy.fft.fft2(原始影像)
        2. 為了便於觀察，通常使用numpy.fft.fftshift()將零頻域成分從左上角移動到影像中心位置
    3. 實現傅立葉反轉換
        1. 語法: numpy.fft.ifft2(頻域資料)
        2. 若移動過零頻域分量，那麼在反轉換的過程，需使用numpy.fft.ifftshift()先將零頻域分量復位
    3. 高通濾波範例
        1. 允許低頻訊號通過的濾波器稱為低通濾波器。低通濾波器使高頻訊號衰減而對低頻訊號放行，會使影像變模糊
        2. 允許高頻訊號通過的濾波器稱為高通濾波器。高通濾波器使低頻訊號衰減而對高頻訊號放行，會增強影像中尖銳的細節，但會導致影像比較度降低
        3. 將傅立葉轉換後頻域影像的低分頻量值取代為0，隱藏低頻訊號保留高頻訊號，實現高通濾波
        4. 頻域影像中心位置，上下左右各30像素大小的區域，將這個區域內的像素值置零
3. OpenCV實現傅立葉轉換[demo]
    1. 傅立葉轉換
        1. 語法: cv2.dft()
    2. 移動零頻域分量
        1. 語法: np.fft.fftshift()
    3. 計算頻譜資訊的幅度
        1. 語法: cv2.magnitude()
    4. 傅立葉反轉換
        1. 語法: cv2.idft()
    5. 低通濾波範例
        1. 將傅立葉轉換後頻域影像的高分頻量值取代為0，隱藏高頻訊號保留低頻訊號，實現低通濾波
        2. 建立遮罩將位於頻域影像中心附近以外的區域像素值置零
## 15 範本比對
1. 範本比對基礎[demo]
    1. 語法: cv2.matchTemplate()
    2. 範本影像必須小於等於原始影像，並且與原始影像相同類型
## 16 霍夫轉換
霍夫轉換應用於在影像中尋找直線、圓形以及其他簡單形狀
1. 霍夫直線轉換
    1. HoughLines函數[demo]
        1. 函數: cv2.HoughLines()
        2. 操作來源影像為二值影像
        3. 檢測結果為影像中的直線而非線段，因此檢測到的直線是沒有端點的
    2. HoughLinesP函數
        1. 機率霍夫轉換是基本霍夫轉換演算法的最佳化；1. 所接受直線的最小長度 2.接受直線的最大像素點間距
        2. 函數: cv2.HoughLinesP()
2. 霍夫圓環轉換[demo]
    1. 只要是能夠用一個參數方程式表示的物件，都適合用霍夫轉換來檢測
    2. 函數: cv2.HoughCircles()
    3. 是否接受圓的參數
        1. 圓心間最小距離
        2. 圓的最小半徑
        3. 圓的最大半徑 
## 17 影像分割與分析
1. 用分水嶺演算法實現影像分割與分析[]
    1. 基本步驟
        1. 透過形態學開運算對原始影像O去噪
        2. 透過腐植操作取得確定背景B
        3. 利用距離轉換函數cv2.distanceTransform()對原始影像進行運算，並利用設定值取得確定前景F
        4. 計算未知區域UN (UN = O-B-F) 
        5. 利用函數cv2.connectedComponents()對原始影像O進行標記
        6. 對函數cv2.connectedComponents()的標記結果進行修正
        7. 利用分水嶺函數cv2.watershed()對影像進行分割
## 18 視訊處理
1. VideoCapture類別
    1. 初始化
        1. 函數: cv2.VideoCapture()
    2. 檢查初始化是否成功
        1. 函數: cv2.VideoCapture.isOpened()
    3. 開啟攝影機
        1. 函數: cv2.VideoCapture.open()
    4. 捕捉頁框
        1. 函數: cv2.VideoCapture.read()
    5. 釋放
        1. 函數: cv2.VideoCapture.release()
    6. 屬性設定
        1. 函數: cv2.VideoCapture.get() 
    7. 指向下一頁框(幀)
        1. 函數: cv2.VideoCapture.grab() 
    8. 解碼並傳回下一頁框(幀)
        1. 函數: cv2.VideoCapture.retrieve() 
2. VideoWriter類別
    1. 建置函數並初始化
        1. 函數: cv2.VideoWriter()
    2. 寫入下一頁框視訊
        1. 函數: cv2.VideoWriter.write(image)
    3. 釋放
        1. 函數: cv2.VideoWriter.release() 
3. 視訊操作基礎
    1. 將視訊頁框從視訊中分析出，對其使用影像處理的方法進行處理，就可以達成處理視訊的目的
## 19 繪圖及互動
1. 繪畫基礎
    1. 繪製直線
    2. 繪製矩形
    3. 繪製圓形
    4. 繪製橢圓
    5. 繪製多邊形
    6. 在圖形上繪製文字
2. 滑鼠互動
3. 捲軸
## 20 K近鄰演算法
1. 理論基礎
    1. 將指定物件根據已知特徵值分類
2. 計算[]
    1. K近鄰演算法在取得各個樣本的特徵值後，計算待測物的特徵值與各個已知分類的樣本特徵值的距離，然後找出k個最鄰近的樣本，根據k個最鄰近樣本中百分比最高的樣本所屬分類，來確認待測物的分類
3. 自訂函數手寫數字辨識
    1. k近鄰演算法函數: cv2.KNearest()
## 21 支援向量機
支援向量機 (Support Vector Machine, SVM) 是一種二分類模型，目標在尋找一個標準 (超平面) 對樣本進行分割，分割原則是確保分類最佳化 (類別之間的間隔最大)
1. SVM案例介紹[demo]
    1. 空分類器模型
          1. 語法: svm = cv2.m1.SVM_create()
    2. 根據資料進行訓練
          1. 語法: svm.train()
    3. 使用分類器進行分類  
          1. 語法: svm.predict()
## 22 K平均值分群
根據訓練資料是否有標籤，可以將學習劃分為監督式學習與非監督式學習。K近鄰與支援向量機都是監督式學習，提供標籤的資料給演算法學習，然後對資料分類，而分群式無監督式學習，事先並不知道分類標籤是甚麼，直接對資料分類
1. K平均值分群的基本步驟
K平均值分群是一種將輸入資料劃分為K個簇的簡單分群演算法，該演算法不斷分析目前分類的中心點，並最後在分類穩定時完成分群
    1. 隨機選取K個點作為分類的中心
    2. 將每個數據點放到距離他最近的中心點所在類別
    3. 重新計算每個分類的資料點的平均值，將平均值做為新的分類中心點
    4. 重複步驟2與步驟3，直到分類穩定
2. K平均值聚類模組[demo]
    1. 函數: cv2.kmeans()
## 23 人臉辨識
1. 人臉識別
    1. 串聯分類器
        1. 將多個簡單為基礎的分類器按照一定順序串聯
    2. Harr串聯分類器
    3. 函數: cv2.CascadeClassifier.detectMultiScale()
2. LBPH人臉辨識
    1. 原理: LBPH (Local Binary Patterns Histogram，局部二值長條圖) 所使用模型基於LBP演算法，LBP在表述影像局部紋理特徵上效果出色
    2. 產生空模型
        1. 函數: cv2.face.LBPHFaceRecognizer_create()
    3. 訓練模型
        1. 函數: cv2.face_FaceRecognizer.train()
    4. 模型預測
        1. 函數: cv2.face_FaceRecognizer.predict()    
3. EigenFaces人臉辨識
    1. 使用主成分分析 (Principal Component Analysis, PCA) 方法將高維的人臉資料處理為低維資料後，再進行資料分析和處理，取得識別結果
    2. 產生空模型
        1. 函數: cv2.face.EigenFaceRecognizer_create()
    3. 訓練模型
        1. 函數: cv2.face_FaceRecognizer.train()
    4. 模型預測
        1. 函數: cv2.face_FaceRecognizer.predict()    
4. FisherFaces人臉辨識
    1. 使用LDA (Linear Discriminant Analysis，線性判別分析) 實現人臉識別，在對特徵降維同時考慮類別資訊，相同類別應緊密聚集在一起；不同類別應盡可能分開
    2. 產生空模型
        1. 函數: cv2.face.FisherFaceRecognizer_create()
    3. 訓練模型
        1. 函數: cv2.face_FaceRecognizer.train()
    4. 模型預測
        1. 函數: cv2.face_FaceRecognizer.predict()    
